package transactions;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import main.AppUtil;
import main.ErrorCode;
import main.FSUtil;

import primitives.Handle;
import primitives.Lock;
import proto.RPCProtos.DataResponse;
import proto.RPCProtos.Update;
import proto.RPCProtos.VersionUpdate;
import proto.RPCProtos.Update.Builder;
import tests.CallResultListener;

public class TransactionClient extends TransactionNodeBase {
    private class PendingUpdate extends Object { // <---  aaahahahaha
        @SuppressWarnings("unchecked")
        public Handle resultHandle; // for returning results after the transaction has completed
        public String filename;
        public int version;
        public Update.Type type;
        public String contents; // for a get(), we need to print the results to the screen 
        // after the transaction has been committed successfully
        
        @SuppressWarnings("unchecked")
        public PendingUpdate(Handle resultHandle, String filename, int version, Update.Type mod) {
            this.resultHandle = resultHandle;
            this.filename = filename;
            this.version = version;
            this.type = mod;
        }
        
        @SuppressWarnings("unchecked")
        public PendingUpdate(Handle resultHandle, String filename, int version, Update.Type mod, String contents) {
            this(resultHandle, filename, version, mod);
            this.contents = contents;
        }
        
        @Override
        public String toString() {
            return "PendingUpdate: filename " + filename + " version " + version + " type " + type;
        }
    }
    
    // are we currently processing a transaction?
    private boolean processingTransaction = false;
    // the highest ranked modification for each file we've made within the current transaction
    private Map<String, Update.Type> fileModifications = new HashMap<String, Update.Type>();
    // the ordered log of updates we've made for the current transaction
    private List<PendingUpdate> transactionLog = new  ArrayList<PendingUpdate>();
    // interface to FS
    private FSUtil filesystem;
    // files currently in our cache
    // filename -> version number
    private Map<String, Integer> fileVersions = new HashMap<String, Integer>();
    // We need to  need to make all operations on the client linearized in case the
    // user makes logic decisions based on previous operations
    private Lock lock = new Lock();
    // whether the current transaction did not begin with a txStart()
    private boolean singleOperationTransaction = false;
    
    public TransactionClient(TransactionNode n) {
        super(n);
    }
    
    public void start() {
        this.filesystem = new FSUtil(this.n);
    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    protected void abort() {
        if(processingTransaction) {
            logError("aborting transaction mmmmk...");
            clearCache(fileModifications.keySet());
            clearState();
        }
    }
    
    private void clearState() {
        processingTransaction = false;
        singleOperationTransaction = false;
        fileModifications.clear();
        transactionLog.clear();
    }
    
    // do we really need to do this? we can easily just leave a bunch of garbage on our FS
    private void clearCache(Collection<String> files) {
        for(String filename : files) {
            try {
                filesystem.deleteFile(filename);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void txStart() {
        log("txstart");
        if(processingTransaction) {
            logError("Warning: already processing a tx! flushing old transaction...");
            abort(); // flush out the previous transaction... clients can only run one transaction at a time
        }
        processingTransaction = true;
    }
    
    private void txAbort() {
        log("txabort");
        if(!processingTransaction) {
            logError("received a txabort without a previous txcommit");
            return;
        }
        
        abort();
    }
    
    private Handle<Object> txCommit() {
        final Handle<Object> commitHandle = new Handle<Object>();
        singleOperationTransaction = false;
        
        if(!processingTransaction) {
            logError("received a txCommit without a previous txstart");
            commitHandle.completedError(ErrorCode.ERR_NONE); // XXX?
            return commitHandle;
        }
        
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                final List<Update> compressedTxLog = compressTxLog();
                
                Handle<List<VersionUpdate>> callResult = sendCommitAttempt(TransactionNode.MANAGER, compressedTxLog);
                callResult.addListener(new Handle.Listener<List<VersionUpdate>>() {
                    @SuppressWarnings("unchecked")
                    @Override
                    public void onSuccess(List<VersionUpdate> versionUpdates) {
                        for(VersionUpdate update : versionUpdates) {
                            fileVersions.put(update.getFilename(), update.getVersion());
                        }
                        
                        // notify all pending calls of success
                        for(PendingUpdate pending : transactionLog) {
                            pending.resultHandle.completedSuccess(pending.contents);
                        }
                        
                        commitHandle.completedSuccess(null);
                        clearState();
                        lock.release();
                    }
                    
                    @Override
                    public void onError(int err) {
                        // notify all pending calls of error   (/which/ file is the error associated with?....)
                        for(PendingUpdate pending : transactionLog) {
                            pending.resultHandle.completedError(err);
                        }
                        abort();
                        commitHandle.completedError(err);
                        lock.release();
                    }
                });
            }
        });
        
        return commitHandle;
    }
    
    // rather than sending the complete list of updates to the server, we 
    // compress the transaction log so that the server only needs to process the
    // most recent update to each file
    // precondition: no multiple create()s delete()s for any file
    private List<Update> compressTxLog() {
        // consider the following transaction:
        //  1. create A
        //  2. get B
        //  3. put A
        //  4. get A
        //  5. put B
        //
        // the /data/ that we want to send to the server is from the last write (3, 5).
        // the update /type/ we want to return is the highest in the sequence (1, 5)
        // Does the order of the "threads" (series of modifications to any given file) 
        // matter? We could send this to the server:
        // [[file A, contents from 3, type from 1], 
        //  [file B, contents from 5, type from 5]]
        // 
        // or we could send this:
        // [[file B, contents from 5, type from 5],
        //  [file A, contents from 3, type from 1]]
        //
        // Does it matter? It seems like it shouldn't...
        
        Map<String, String> mostRecentContents = new HashMap<String, String>();
        List<Update> compressedTxLog = new ArrayList<Update>();
        
        List<PendingUpdate> reversedLog = new ArrayList<PendingUpdate>(transactionLog);
        Collections.reverse(reversedLog);
        for(PendingUpdate pendingUpdate : reversedLog) {
            if(pendingUpdate.type == Update.Type.Write &&
                    !mostRecentContents.containsKey(pendingUpdate.filename)) {
                mostRecentContents.put(pendingUpdate.filename, pendingUpdate.contents);
            }
        }
        
        for(String filename : fileModifications.keySet()) {
            Builder update = Update.newBuilder()
                .setFilename(filename)
                .setType(fileModifications.get(filename));
                
            if(fileVersions.containsKey(filename))
                update.setVersion(fileVersions.get(filename));
            
            if(mostRecentContents.containsKey(filename))
                update.setContents(mostRecentContents.get(filename));
                
            compressedTxLog.add(update.build());
        }
        
        log("Compressed transaction log:" + compressedTxLog.toString().replace("\n", " "));
        
        return compressedTxLog;
    }
    
    @Override
    public void onCommand(String command) {
        try {
            String[] args = null;
            if (command.startsWith("txstart")) {
                txStart();
                
            } else if (command.startsWith("txcommit")) {
                txCommit().addListener(new CallResultListener<Object>("txcommit", this));
                
            } else if (command.startsWith("txabort")) {
                txAbort();
                
            } else if (command.startsWith("create ")) { // create filename
                args = AppUtil.splitArgs(command, 2);
                create(args[1]).addListener(new CallResultListener<Object>("create", this));
                
            } else if (command.startsWith("get ")) { // get filename
                args = AppUtil.splitArgs(command, 2);
                // CallResultListener is actually the exact functionality we want out of the get handler, 
                // since it prints the results to the screen
                get(args[1]).addListener(new CallResultListener<String>("get", this));
                
            } else if (command.startsWith("put ")) { // put filename contents
                args = AppUtil.splitArgs(command, 3);
                put(args[1], args[2]).addListener(new CallResultListener<Object>("put", this));
                
            } else if (command.startsWith("append ")) { // append filename contents
                args = AppUtil.splitArgs(command, 3);
                append(args[1], args[2]).addListener(new CallResultListener<Object>("append", this));
                
            } else if (command.startsWith("delete ")) { // delete filename
                args = AppUtil.splitArgs(command, 2);
                delete(args[1]).addListener(new CallResultListener<Object>("delete", this));
                
            } else if(command.startsWith("info")) { // info
                log("processingTransaction " + processingTransaction);
                log("fileModifications: " + fileModifications);
                log("transactionLog: " + transactionLog);
                log("fileVersions: " + fileVersions);
                log("lock:" + lock);
            } else {
                n.logError("unkown command: " + command);
            }
        } catch(IllegalArgumentException e) {
            // This also catches NumberFormatException from Integer.parseInt()
            logError("bad command syntax");
        }
    }
    
    // We use a crazy state machine to update our modification level:
    // 
    //  return: the error code of a failed modification, or zero if the modification change was successful
    // TODO: this is far too C-like -- throw an exception? That would require defining a new exception type...
    private int updateModificationLevel(String filename, Update.Type newMod) {
        if(!fileModifications.containsKey(filename)) {
            fileModifications.put(filename, newMod);
            return 0;
        } else {
            Update.Type oldMod = fileModifications.get(filename);
            switch(oldMod) {
            case Read: 
                if(newMod == Update.Type.Create) {
                    return ErrorCode.ERR_FILE_EXISTS;
                } else {
                    fileModifications.put(filename, newMod); // R->W, R->R, or R->D
                }
                break;
            case Write:
                if(newMod == Update.Type.Create) {
                    return ErrorCode.ERR_FILE_EXISTS;
                } else if(newMod == Update.Type.Delete) {
                    fileModifications.put(filename, newMod);
                } // else if R, W->W, else if W, W->W
                break;
            case Create: 
                if(newMod == Update.Type.Create) {
                    return ErrorCode.ERR_FILE_EXISTS;
                } else if(newMod == Update.Type.Delete) { // C->D, remove ourselves from the the log entirely (temp file)
                    fileModifications.remove(filename);
                    purgeFileFromLog(filename);
                } // else if R, C->C, else if W, C->C
                break;
            case Delete:
                if(newMod == Update.Type.Create) {
                    logError("Creates following deletes are disallowed... if you want to empty a file, call put(\"\")");
                    return ErrorCode.ERR_ILLEGAL_OPERATION;
                } else { // R, W, D, -> no such file
                    return ErrorCode.ERR_FILE_NOT_FOUND;
                }
            }
        }
        return 0;
    }
    
    // called on a Delete followed by a Create (don't tell the server anything)
    private void purgeFileFromLog(String filename) {
        // java, I hate you
        for(Iterator<PendingUpdate> it = transactionLog.iterator(); it.hasNext(); )
            if(it.next().filename.equals(filename))
                it.remove();
    }
    
    // we treat any commands not surrounded by txstart and txcommit as a single
    // operation transaction
    private void ensureTransactionStart() {
        if(!processingTransaction) {
            singleOperationTransaction = true;
            txStart();
        }
    }
    
    private void ensureTransactionEnd() {
        if(singleOperationTransaction) {
            txCommit();
        }
    }
    
    // update our cache whenever we get a DataResponse
    private void updateCache(DataResponse response) throws IOException {
        fileVersions.put(response.getFilename(), response.getVersion());
        filesystem.writeContents(response.getFilename(), response.getContents());
    }

    private Handle<Object> create(final String filename) {
        final Handle<Object> resultHandle = new Handle<Object>();
        
        ensureTransactionStart();
        
        // even though a create() is executed in a single event, we need to linearize
        // operations within a single transaction. For example, the user may execute
        //     get A
        //     create B
        // we cannot create B until A has completed, hence the lock
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                int err;
                if((err = updateModificationLevel(filename, Update.Type.Create)) != 0) {
                    resultHandle.completedError(err);
                    abort();
                    l.release();
                    return;
                }
                PendingUpdate update = 
                    new PendingUpdate(resultHandle, filename, 0, Update.Type.Create);
                transactionLog.add(update);
                fileVersions.put(filename, 0);
                try {
                    filesystem.createFile(filename);
                } catch (IOException e) {
                    resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                    abort();
                    lock.release();
                    return;
                }
                ensureTransactionEnd();
                lock.release();
            }
        });
        
        return resultHandle;
    }
    
    private Handle<String> get(final String filename) {
        final Handle<String> resultHandle = new Handle<String>();
        
        ensureTransactionStart();
        
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                int err;
                if((err = updateModificationLevel(filename, Update.Type.Read)) != 0) {
                    resultHandle.completedError(err);
                    abort();
                    l.release();
                    return;
                }
                
                if(fileVersions.containsKey(filename)) {
                    int version = fileVersions.get(filename);
                    PendingUpdate update = 
                        new PendingUpdate(resultHandle, filename, version, Update.Type.Read);
                    try {
                        update.contents = filesystem.getContents(filename);
                    } catch (IOException e1) {
                        resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                        abort();
                        lock.release();
                        return;
                    }
                    transactionLog.add(update);
                    ensureTransactionEnd();
                    lock.release();
                } else {
                    // not in our cache
                    Handle<DataResponse> result = sendDataRequest(TransactionNode.MANAGER, filename);
                    result.addListener(new Handle.Listener<DataResponse>() {
                        @Override
                        public void onSuccess(DataResponse data) {
                            int version = data.getVersion();
                            String contents = data.getContents();
                            try {
                                updateCache(data);
                            } catch (IOException e) {
                                resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                                abort();
                                lock.release();
                                return;
                            }
                            
                            PendingUpdate update = 
                                new PendingUpdate(resultHandle, filename, version, Update.Type.Read, contents);
                            transactionLog.add(update);
                            ensureTransactionEnd();
                            lock.release();
                        }
                        
                        @Override
                        public void onError(int err) { 
                            resultHandle.completedError(err);
                            abort();
                            lock.release();
                        }
                    });
                }
            }
        });
        
        return resultHandle;
    }
    
    private Handle<Object> put(final String filename, final String contents) {
        final Handle<Object> resultHandle = new Handle<Object>();
        
        ensureTransactionStart();
        
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                int err;
                if((err = updateModificationLevel(filename, Update.Type.Write)) != 0) {
                    resultHandle.completedError(err);
                    abort();
                    l.release();
                    return;
                }
                
                if(fileVersions.containsKey(filename)) {
                    try {
                        filesystem.writeContents(filename, contents);
                    } catch(IOException e) {
                        resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                        abort();
                        lock.release();
                        return;
                    }
                    int version = fileVersions.get(filename);
                    PendingUpdate update = 
                        new PendingUpdate(resultHandle, filename, version, Update.Type.Write, contents);
                    transactionLog.add(update);
                    ensureTransactionEnd();
                    lock.release();
                } else {
                    // not in our cache
                    Handle<DataResponse> result = sendDataRequest(TransactionNode.MANAGER, filename);
                    result.addListener(new Handle.Listener<DataResponse>() {
                        @Override
                        public void onSuccess(DataResponse data) {
                            int version = data.getVersion();
                            try {
                                updateCache(data); // XXX two disc writes...
                                filesystem.writeContents(filename, contents);
                            } catch (IOException e) {
                                resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                                abort();
                                lock.release();
                                return;
                            }
                            
                            PendingUpdate update = 
                                new PendingUpdate(resultHandle, filename, version, Update.Type.Write, contents);
                            transactionLog.add(update);
                            ensureTransactionEnd();
                            lock.release();
                        }
                        
                        @Override
                        public void onError(int err) { 
                            resultHandle.completedError(err);
                            abort();
                            lock.release();
                        }
                    });
                }
            }
        });
        
        return resultHandle;
    }
    
    private Handle<Object> append(final String filename, final String contents) {
        final Handle<Object> resultHandle = new Handle<Object>();
        
        ensureTransactionStart();
        
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                int err;
                if((err = updateModificationLevel(filename, Update.Type.Write)) != 0) {
                    resultHandle.completedError(err);
                    abort();
                    l.release();
                    return;
                }
                
                if(fileVersions.containsKey(filename)) {
                    String updatedContents = "";
                    try {
                        filesystem.appendContents(filename, contents);
                        updatedContents = filesystem.getContents(filename); // XXX kludge..
                    } catch (IOException e) {
                        resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                        abort();
                        l.release();
                        return;
                    }
                    int version = fileVersions.get(filename);
                    PendingUpdate update = 
                        new PendingUpdate(resultHandle, filename, version, Update.Type.Write, updatedContents);
                    transactionLog.add(update);
                    ensureTransactionEnd();
                    l.release();
                } else {
                    // not in our cache
                    Handle<DataResponse> result = sendDataRequest(TransactionNode.MANAGER, filename);
                    result.addListener(new Handle.Listener<DataResponse>() {
                        @Override
                        public void onSuccess(DataResponse data) {
                            int version = data.getVersion();
                            try {
                                updateCache(data);
                                filesystem.appendContents(filename, contents);
                            } catch (IOException e) {
                                resultHandle.completedError(ErrorCode.ERR_IO_EXCEPTION);
                                abort();
                                lock.release();
                                return;
                            }
                            String updatedContents = new StringBuilder(data.getContents())
                                .append(contents).toString();
                            
                            PendingUpdate update = 
                                new PendingUpdate(resultHandle, filename, version, Update.Type.Write, updatedContents);
                            transactionLog.add(update);
                            ensureTransactionEnd();
                            lock.release();
                        }
                        
                        @Override
                        public void onError(int err) { 
                            resultHandle.completedError(err);
                            abort();
                            lock.release();
                        }
                    });
                }
            }
        });
        
        return resultHandle;
    }
    
    private Handle<Object> delete(final String filename) {
        final Handle<Object> resultHandle = new Handle<Object>();
        
        ensureTransactionStart();
        
        // even though a delete() is executed in a single event, we need to linearize
        // operations within a single transaction. For example, the user may execute
        //     get A
        //     create B
        // we cannot create B until A has completed, hence the lock
        lock.acquire(new Lock.Callback() {
            @Override
            public void run(Lock l) {
                int err;
                if((err = updateModificationLevel(filename, Update.Type.Delete)) != 0) {
                    resultHandle.completedError(err);
                    abort();
                    l.release();
                    return;
                }
                PendingUpdate update = 
                    new PendingUpdate(resultHandle, filename, 0, Update.Type.Delete);
                transactionLog.add(update);
                fileVersions.remove(filename);
                // XXX just let the file sit on our disc...?
                ensureTransactionEnd();
                l.release();
            }
        });
        
        return resultHandle;
    }
    
    public void handleInvalidateRequest(int from, List<String> files) {
        log("received InvalidateRequest from " + from);
        
        // If we are in the middle of a transaction that uses an out-of-date
        // file, we know right away that our transaction will be aborted at the server,
        boolean foundConflict = false;
        for(String file : files) {
            fileVersions.remove(file);
            if(fileModifications.containsKey(file)) {
                foundConflict = true;
            }
            
            // XXX remove from FS?
        }
        
        if(foundConflict) {
            abort();
        }
    }
}
